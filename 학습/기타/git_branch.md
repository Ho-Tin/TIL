요청하신 두 번째 동영상(Git Branch)의 내용도 요약하여 Markdown(.md) 파일 형식으로 작성했습니다.

---

# 삼성청년 SW·AI 아카데미: Git Branch & Merge 요약

이 문서는 '삼성청년 SW·AI 아카데미'의 Git 강의 중 **Branch(브랜치)**와 **Merge(병합)**에 관련된 내용을 요약한 것입니다.

## 1. 🌿 Git Branch

### 브랜치란? (00:02)

나뭇가지처럼 여러 갈래로 **작업 공간을 나누어** 독립적으로 개발을 수행할 수 있도록 도와주는 Git의 핵심 도구입니다.

### HEAD란? (00:05)

현재 내가 바라보는 위치(작업 중인 브랜치 또는 커밋)를 가리키는 **포인터**입니다.

### 주요 Branch 명령어 (00:04)

| 명령어 | 기능 |
| :--- | :--- |
| `git branch` | 로컬 브랜치 목록 확인 ( `*` 는 현재 HEAD 위치) |
| `git branch -r` | 원격 저장소의 브랜치 목록 확인 |
| `git branch <브랜치 이름>` | 새로운 브랜치 생성 |
| `git branch -d <브랜치 이름>` | 병합이 완료된 브랜치 삭제 |
| `git branch -D <브랜치 이름>` | (병합 여부와 상관없이) 강제로 브랜치 삭제 |
| `git switch <브랜치 이름>` | 해당 브랜치로 `HEAD`를 이동 (전환) |

### 브랜치 시나리오 (00:08 ~ 00:18)

1.  **브랜치 생성:** `git branch login` 명령어로 `login` 브랜치를 생성합니다. 이 시점에는 `master`와 `login`이 동일한 커밋을 가리킵니다.
2.  **커밋 생성:** `login` 브랜치로 이동(`switch`)하여 새 커밋을 생성하면, `login` 브랜치 포인터는 새 커밋을 가리키도록 이동하지만 `master` 포인터는 그대로 있습니다. 이로써 두 브랜치가 **분기**됩니다.
3.  **로그 확인:** `git log --oneline --all --graph` 명령어를 사용하면 모든 브랜치의 커밋 내역과 분기 상태를 그래프로 쉽게 확인할 수 있습니다.

---

## 2. 🔄 Git Merge (병합)

분기된 두 브랜치를 하나의 브랜치로 다시 합치는(결합하는) 작업입니다.

### 1. Fast-Forward Merge (빨리 감기) (00:22 ~ 00:26)

* **상황:** 병합할 브랜치(`master`)가 분기된 이후 **아무런 추가 커밋이 없는** 상태에서, 분기된 브랜치(`hotfix`)를 병합하려 할 때 발생합니다.
* **동작:** 별도의 "병합 커밋"을 생성하지 않고, `master` 브랜치 포인터가 `hotfix` 브랜치가 가리키는 최신 커밋으로 **그대로 이동**합니다. (마치 빨리 감기처럼)

### 2. 3-Way Merge (00:27 ~ 00:31)

* **상황:** `master`와 `hotfix` 브랜치가 **각자 고유의 추가 커밋**을 가지고 있어, 브랜치가 실제로 갈라진(Diverged) 상태일 때 발생합니다.
* **동작:**
    1.  두 브랜치의 **공통 조상 커밋**을 찾습니다.
    2.  `master`의 최신 커밋과 `hotfix`의 최신 커밋, 그리고 공통 조상 커밋 (총 3개)을 비교합니다.
    3.  두 브랜치의 변경 사항을 모두 합친 **새로운 병합 커밋(Merge Commit)**을 생성합니다.

### 3. Merge Conflict (병합 충돌) (00:32 ~ 00:39)

* **원인:** 병합하려는 두 브랜치가 **"동일한 파일의 동일한 부분"**을 서로 다르게 수정했을 때 발생합니다. Git이 자동으로 결정할 수 없어 사용자에게 해결을 요청합니다.
* **해결 과정:**
    1.  충돌이 발생한 파일에는 `<<<<<<< HEAD`, `=======`, `>>>>>>>` 마커가 표시됩니다.
    2.  개발자가 **직접 파일을 열어** 원하는 내용으로 **수정**하고 마커를 제거합니다.
    3.  수정 완료된 파일을 `git add` 명령어로 Staging Area에 추가합니다.
    4.  `git commit` 명령어를 실행하여 병합 커밋을 생성하고 충돌 해결을 완료합니다.

---

## 3. 🤝 협업 워크플로우 (Workflows)

### 1. Feature Branch Workflow (00:41)

* **개념:** 공유 저장소 모델(Shared Repository)에서 사용하는 방식입니다.
* **프로세스:**
    1.  기능별로 `feature/login`, `feature/signup` 같은 브랜치를 생성하여 작업합니다.
    2.  작업이 완료되면 원격 저장소(e.g., GitHub)에 해당 브랜치를 `push` 합니다.
    3.  **풀 리퀘스트(Pull Request, PR)**를 생성하여 `master` (또는 `develop`) 브랜치로 병합을 요청합니다.
    4.  동료의 **코드 리뷰** 후 병합을 승인합니다.

### 2. Git Flow (00:48)

* 더 구조화된 브랜치 전략입니다.
* **주요 브랜치:**
    * `master` (main): 실제 배포(릴리즈)된 안정적인 버전.
    * `develop`: 다음 릴리즈를 위해 개발 중인 내용을 통합하는 브랜치.
    * `feature/*`: `develop`에서 분기하여 기능을 개발하는 브랜치. (개발 후 `develop`로 병합)
    * `release/*`: `develop`에서 분기하여 배포 전 QA, 버그 수정을 진행하는 브랜치. (완료 후 `master`와 `develop`에 병합)
    * `hotfix/*`: `master`에서 발생한 치명적인 버그를 긴급 수정하는 브랜치. (완료 후 `master`와 `develop`에 병합)

### 3. Forking Workflow (00:51)

* **개념:** 주로 **오픈 소스 프로젝트**에서 사용하는 방식입니다. 저장소에 대한 쓰기 권한이 없는 외부 기여자가 참여할 수 있습니다.
* **프로세스:**
    1.  기여자가 원본(`Upstream`) 저장소를 자신의 계정으로 **Fork** 합니다. (내 계정에 복사본 생성)
    2.  자신의 `Origin` 저장소(Fork한 저장소)에서 작업 브랜치를 생성하고 `push` 합니다.
    3.  원본(`Upstream`) 저장소로 **Pull Request**를 보냅니다.
    4.  원본 저장소의 **관리자(Maintainer)**가 코드를 리뷰하고 병합을 승인합니다.