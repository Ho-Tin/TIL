요청하신 대로 영상 속 **이론적인 배경과 개념 설명**을 대폭 보강하고, **코드 부분**은 요약 없이 상세하게 정리하여 다시 작성해 드립니다.

---

# Pandas 기초 및 데이터 분석 개론 (상세 정리)

## 1. 데이터 분석의 중요성 및 역할

### 1.1 데이터 분석은 왜 하는가?

과거의 직관에 의존한 결정이 아닌, **데이터에 기반한 합리적인 의사결정**을 내리기 위함입니다.

* **비즈니스 사례:**
* **카페 창업:** 대학가와 주거 밀집 지역 중 어디가 장사가 더 잘될까? (폐업률 분석)
* **쇼핑몰:** 어떤 상품이 잘 팔리며, 어떤 상품을 함께 진열해야 할까?
* **배달 서비스:** 어느 시간대에 배달원이 가장 많이 필요할까?
* **채용:** 어떤 부서에 인력을 충원해야 회사가 성장할까?
* **제조업:** 불량률을 낮추기 위해 어떤 공정 단계에서 문제가 발생하는지 파악.



### 1.2 데이터 분석의 프로세스

데이터 분석은 단순히 데이터를 보는 것이 아니라, **문제 정의부터 결과 공유까지의 일련의 과정**입니다.

1. **문제 정의 (Problem Definition):** 해결해야 할 핵심 질문을 던집니다. (예: "응급센터의 적정 규모는 얼마인가?")
2. **데이터 기획:** 문제 해결에 필요한 데이터를 정의합니다. (예: 인구 밀도, 병원 위치, 응급 환자 발생률 등)
3. **데이터 수집:** 설문, DB 조회, 크롤링 등을 통해 데이터를 모읍니다.
4. **데이터 전처리:** 수집된 데이터를 분석 가능한 형태로 다듬습니다. (오류 수정, 결측치 처리)
5. **분석 및 모델링:** 통계 분석이나 머신러닝 모델을 통해 가설을 검증합니다.
6. **결과 공유:** 시각화나 보고서를 통해 인사이트를 전달합니다.

### 1.3 데이터 분석의 실제 업무 사례 (SOCAR 예시)

영상에서는 쏘카(SOCAR)의 실제 사례를 들어 분석 과정을 설명했습니다.

* **현상:** 코로나 시국에 쏘카존 이용 시간은 감소했으나, 매출은 오히려 증가함.
* **분석:**
* 과거 데이터를 뜯어보니 **"연령별로, 시간대별로 매출 차이가 난다"**는 것을 발견.
* 30대의 수요는 증가했으나, 대학가(한양대) 근처의 수요는 감소함.
* 대신 뚝섬(업무 지구) 지역의 차량이 부족해짐.


* **결론 및 액션:** 대학가(한양대)에 남는 차량을 수요가 넘치는 뚝섬으로 이동 배치하여 운영 효율을 높임.

### 1.4 데이터 사이언스 필요 역량

데이터 분석가에게는 세 가지 핵심 역량의 교집합이 필요합니다.

1. **Computer Science:** 프로그래밍, 머신러닝 구현 능력
2. **Math & Statistics:** 통계학적 지식, 선형대수
3. **Business / Domain Expertise:** 해당 산업 분야에 대한 이해도

---

## 2. 파이썬 데이터 분석 생태계와 Pandas

### 2.1 파이썬 머신러닝 생태계 구조

파이썬은 다양한 라이브러리들이 유기적으로 연결되어 있습니다.

* **Scikit-learn:** 머신러닝 알고리즘 제공
* **NumPy / SciPy:** 배열 연산, 선형대수, 통계 연산 (기초 수치 계산 담당)
* **Pandas:** **데이터 핸들링** (데이터를 읽고, 자르고, 붙이는 전처리 담당)
* **Matplotlib / Seaborn:** 데이터 시각화
* **Jupyter:** 대화형 파이썬 툴 (분석 환경)

### 2.2 Pandas란 무엇인가?

* **개념:** 관계형(Relational) 또는 레이블이 붙은(Labeled) 데이터를 쉽고 직관적으로 다루기 위해 설계된 파이썬 라이브러리입니다. 엑셀의 스프레드시트와 유사한 형태인 **DataFrame**을 주로 다룹니다.
* **NumPy 기반:** 고성능 수치 계산 라이브러리인 NumPy를 기반으로 만들어져 속도가 빠르고 다른 라이브러리와 호환성이 좋습니다.

### 2.3 Pandas의 장점

1. **결측치 처리 용이:** 데이터가 비어있는 부분(`NaN`)을 쉽게 찾고, 삭제하거나 다른 값으로 채울 수 있습니다.
2. **데이터 조작:** 행/열의 추가, 삭제, 정렬이 자유롭습니다.
3. **SQL 같은 기능:** 데이터의 그룹화(`groupby`), 병합(`merge`, `join`) 등의 복잡한 연산을 간단한 코드로 수행합니다.
4. **다양한 입출력:** CSV, Excel, DB, JSON 등 다양한 포맷의 데이터를 읽고 쓸 수 있습니다.

---

## 3. Pandas 주요 데이터 구조 및 생성 (Code 상세)

### DataFrame과 Series의 구조적 차이

* **DataFrame:** 행(Index)과 열(Columns)이 있는 **2차원** 테이블 구조입니다. (엑셀 시트 전체)
* **Series:** DataFrame에서 하나의 열(Column)만 떼어낸 것과 같은 **1차원** 배열 구조입니다. (Index와 Value로 구성)

```python
import pandas as pd

# 1. DataFrame 생성
# Dictionary를 사용하여 생성하면 Key가 컬럼명, Value가 데이터 리스트가 됨
df = pd.DataFrame({
    "Name": ["김싸피", "최영희", "강민수"],
    "Age": [25, 37, 19],
    "Class": ["Data", "Web", "AI"]
})
# 결과: 3행 3열의 표 형태 데이터 생성

# 2. Series 생성
# 1차원 데이터, 자동으로 0부터 시작하는 인덱스가 부여됨
ages = pd.Series([22, 35, 58], name="Age")
print(ages)

```

### 파일 데이터 읽어오기

가장 많이 사용되는 기능으로, 외부 파일을 DataFrame으로 변환합니다.

```python
# CSV 파일 읽기 (Comma Separated Values)
# 첫 번째 줄을 헤더(컬럼명)로 인식하는 것이 기본 설정
titanic = pd.read_csv('titanic.csv')

# 참고: 엑셀 파일은 pd.read_excel(), JSON은 pd.read_json() 사용

```

---

## 4. 데이터 확인 및 탐색 (Code 상세)

데이터를 로드한 후, 데이터의 생김새와 통계적 특성을 파악하는 필수 단계입니다.

```python
# 1. 상위/하위 데이터 확인
# 데이터가 잘 불러와졌는지 눈으로 확인
titanic.head()      # 상위 5개 행 출력 (기본값 5)
titanic.tail(3)     # 하위 3개 행 출력

# 2. 데이터프레임 구조 및 정보 확인
print(titanic.shape)    # (행의 수, 열의 수)를 튜플 형태로 반환. 예: (891, 12)

# info(): 데이터 분석 전 가장 먼저 확인해야 할 함수
# - 전체 행의 개수 (RangeIndex)
# - 컬럼별 이름, 데이터 타입(Dtype), 결측치가 아닌 값의 개수(Non-Null Count) 확인 가능
titanic.info()

# 3. 기술 통계량 확인
# 수치형 데이터(int, float)에 대한 요약 통계 제공
# 개수(count), 평균(mean), 표준편차(std), 최솟값(min), 4분위수(25%, 50%, 75%), 최댓값(max)
titanic.describe()

# 4. 범주형 데이터 분포 확인
# 특정 컬럼에 어떤 값이 몇 개나 있는지 확인 (빈도수 측정)
# 기본적으로 결측치(NaN)는 세지 않음
print(titanic['Embarked'].value_counts())

# dropna=False 옵션을 주면 결측치(NaN)의 개수도 포함하여 카운트
print(titanic['Embarked'].value_counts(dropna=False))

```

---

## 5. 데이터 정제 및 전처리 이론과 실습

### 5.1 전처리 이론

* **데이터 전처리란?** 수집된 원본 데이터(Raw Data)를 분석 모델에 넣기에 알맞게 가공하는 과정입니다.
* **주요 작업:**
* 형식 맞추기 (날짜 포맷 통일 등)
* 빈칸 채우기 (결측치 처리)
* 이상치(Outlier) 제거 (논리적으로 말이 안 되거나 분포에서 너무 벗어난 값 처리)



### 5.2 전처리 실습 (Code 상세)

#### 데이터 삭제 (Drop)

불필요한 행이나 열을 제거합니다.

```python
# 컬럼(열) 삭제: axis=1
# 'Age' 컬럼을 삭제한 새로운 DataFrame 반환 (원본 유지)
df_dropped = df.drop('Age', axis=1)

# 원본 데이터프레임에서 바로 삭제하려면 inplace=True 옵션 사용
df.drop('Age', axis=1, inplace=True)

# 행 삭제: axis=0 (기본값)
# 인덱스가 1인 행 삭제
df.drop(1, axis=0, inplace=True)

```

#### 결측치(Missing Value) 처리

데이터 분석에서 가장 중요한 단계 중 하나입니다.

```python
# 1. 결측치 확인 (True/False 반환)
# 전체 데이터프레임에서 결측치 개수 합계 (컬럼별)
print(titanic.isna().sum())

# 특정 컬럼의 결측치 확인
print(titanic['Embarked'].isna().sum())


# 2. 결측치 삭제 (dropna)
# 'Embarked' 컬럼에 NaN이 있는 행(row) 자체를 날려버림
clean_df = titanic.dropna(subset=['Embarked'])
print(clean_df.shape) # 행 개수가 줄어든 것을 확인 가능


# 3. 결측치 채우기 (fillna)
# 삭제가 부담스러울 때, 평균값/중앙값/최빈값 등으로 채움

# 예: 'Embarked'의 최빈값(가장 많이 나온 값) 구하기
most_freq = titanic['Embarked'].value_counts().idxmax()

# NaN 값을 최빈값으로 채워넣기
filled_df = titanic.fillna({'Embarked': most_freq})

```

---

## 6. 인덱싱과 필터링 (Code 상세)

원하는 데이터만 쏙쏙 뽑아내는 방법입니다.

### 6.1 `loc` vs `iloc` (인덱서)

* **`loc` (Label location):** 사람이 읽을 수 있는 **이름(Label)** 기준입니다. "이름이 'Age'인 열을 줘"
* **`iloc` (Integer location):** 컴퓨터가 이해하는 **순서(Index 번호)** 기준입니다. "3번째 열을 줘"

```python
# --- loc 사용법 ---
# [행 이름, 열 이름] 형태
# 인덱스가 5인 행의 'Pclass' 값을 가져옴
print(titanic.loc[5, 'Pclass'])

# 인덱스 2부터 3까지(범위 포함), 'Name'과 'Age' 컬럼 선택
subset = titanic.loc[2:3, ["Name", "Age"]]


# --- iloc 사용법 ---
# [행 번호, 열 번호] 형태 (0부터 시작)
# 5번 행(실제 6번째 데이터), 2번 열(실제 3번째 컬럼) 값
print(titanic.iloc[5, 2])

# 슬라이싱 (파이썬 리스트 슬라이싱과 동일하게 '끝번호 미포함')
# 0행~2행(3개), 0열~1열(2개) 추출
print(titanic.iloc[0:3, 0:2])

```

### 6.2 불린 인덱싱 (Boolean Indexing)

조건문(True/False)을 사용하여 데이터를 필터링하는 가장 강력한 기능입니다.

```python
# 1. 조건에 맞는 행 전체 추출
# 나이가 35세 초과인 승객 데이터만 필터링
age_above_35 = titanic[titanic["Age"] > 35]
print(age_above_35.head())

# 2. 조건에 맞는 행의 특정 열만 추출 (loc과 결합)
# 조건: 나이가 35세 초과
# 추출할 열: "Name"
adult_names = titanic.loc[titanic["Age"] > 35, "Name"]
print(adult_names.head())

# 3. 여러 조건을 결합할 때 (isin 활용)
# Pclass가 2 또는 3인 승객만 추출
class_23 = titanic[titanic["Pclass"].isin([2, 3])]

# (참고) AND(&), OR(|) 연산자 사용 가능
# titanic[(titanic["Age"] > 35) & (titanic["Pclass"] == 1)]

```