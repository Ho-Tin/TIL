## 250728 - 오전
- python 강의
- default dict
### 고수준 언어(기계어로 바꿔주는 번역기)
- 사람이 읽기 쉽다
- python, java
### 저수준 언어
- 기계어(0101010110),어셈블리어
### 파이썬
- 쉽고 간결한 문법
- 세계적인 규모의 커뮤니티
- 파이썬 프로그램 -> 파이썬 인터프리터 -> 운영 체제
- 표현식(Expression) - 값을 꺼내는 것, 값(value), 평가(Evaluate), 문장(Statement)
### 타입(type)
- 의미 있는 연산과 결과 보장
- 오류 예방과 디버깅 용이
- 개발 생산성과 코드 가독성 향상
### 우선순위
- 1순위 (괄호) 
- 2순위 **
- 3순위 -(음수부호)
- 4순위 *,/,%,등등 부호
- 5순위 (덧셈,뺼셈)
### 코딩 작성 괄호 작성시 도움됨<<
### 변수
- 값을 저장하기 위한 이름
- 할당하다, 재할당하다
### 변수,값 메모리
- 변수는 주소를 저장하는 것
- **int(정수) / 진수로도 표현 가능**
- 2진수(0b) binary
- 8진수(0o) octal
- 16진수(0x) hexadecimal
- **지수 표현**
- e또는 E를 사용한 표현
### float - 유한 정밀도
-  무한대를 저장할수 없기 떄문에 2/3 0.66666666 같이 일정 숫자에서 끊어저 저장 (16~17자에서 끊음)
- 부동소수점 에러<<<
실수를 진수로 변환하는 과정에서 발생하는 에러
- **decimal 모듈**을 사용해 에러 방지
- 실수로 저장하기 때문에 문제가 해결됨
- from decimal import Decimal
### sequence Types
- 여러 개의 값들을 **순서대로 나열**하여 저장하는 자료형
- str, 순서가 있고 변경 불가능한 시퀀스 자료형
- 역슬래시(backslash, \) \n 줄바꿈, 엔터 \t 탭
- f-string (f.{a}{b}{c})
- **인덱싱**
- [0]부터 시작
- **슬라이싱**
- hello
- my_str[2:4] 2이상 4미만  'll'
- my_str[0:5:2] 'hlo' 0이상 5미만 2칸씩 
- my_str[::-1] 'olleh' -1이하 전부
- my_str[-4:-2:-2] '' 진행방향이 다르기떄문에 공백
- 문자열은 불면(변경불가)
- 파이썬 스타일 가이드
- **변수명 짓기 중요**
- 주석
- 코드를 이해하거나 문서화하기 위해
- 다른 개발자나 자신에게 코드의 의도나 동작을 설명하는 데 도움
- **나 자신을 위해** 사용
- python 튜터  render all 모시꺵이 작성
 https://pythontutor.com/python-compiler.html#mode=edit

## 250728 - 오후
- list, dict ,set  
- **list** 
- 순서대로 변경 가능한 시퀀스 자료
- 어떤 자료형도 저장할 수 있음
- list는 가변이다 < 변경할수있다>
- [] 사용
- **tuple**
- list와 비슷하지만 변경 불가능
- () 사용--없어도 됨
- , ex   a = (1, )
-  **range**
- range(0,10) 0이상 10 미만 / 0부터 9까지
### non_시퀀스
- **dict**
- 중복도 없고 순서도 없는 변경 가능한 자료형
- EX 노래방 번호 
- key - Value 
- key는 변경 불가능한 자료형만 사용 가능(str,int,float, tuple,range 등등)
- value는 모든 자료형 사용 가능
- defaultdict(list) << list 에 default로 빈값 지정
- **set**
- 순서와 중복이 없는 변경 가능한 자료형
- 수학에서 **집합**과 동일한 연산
- {}로 표시
```
list = [1,2,3,4,1,1,1,1]
print(list) # 1,2,3,4,1,1,1,1
list = set(list)
print(list) #  1,2,3,4
```
- 합집합 |  myset1 | myset2
- 교집합 &  myset1 & myset2
- 차집합 -
- **None**
- 값이 없음을 의도적으로 표현
- **Bool**
- 참(True) 과 거짓(False)를 표현하는 자료형
- 0은 False / 0제외 숫자는 다 True
- **Conversion**
- **암시적 형변환** - 파이썬이 자동으로 형변환 하는 것
- 정수와 실수에서 정수가 실수로 바뀜
- 3 + 5.0 = 8.0 
- True + 3 = 4
### 명시적 형변환 - 직접 지정하는 형번환
- str -> int : 형식에 맞는 숫자마 가능
- "3.5" int("3.5")는 불가능 -> float("3.5") 정수는 실수가 될수없음
- ***연산자***
- **복합 연산자**
- 1+=2 , -=, *=, /+, //=, 등
- 비교 연산자
- == , !=, is, is not
- is 메모리 내에서 같은 객체를 참조하는지 확인 (주소값이 같은지 확인)
- 'str'은 주소값이 바뀌지 않지만 list는 주소값이 바뀜
- **논리 연산자**
- and or not
### 단축평가
- (True and True) ('a' and 'b') 이면 'b' 반환
```
vowels = 'aeiou'
print(('a' and 'b') in vowels) # False
print(('b' and 'a') in vowels) # True
```
- **and 는 False(거짓)이 나오면 중단**
- and 는 True가 나와도 계속 진행
- **or 는 True(참)이 나오면 중단** 
- or 는 False가 나와도 계속 진행
- **멤버쉽 연산자**
- in , not in
0 or 3 or b
## 250729 
- **조건문**
- if, elif, else
- if 표현식:
    -   코드 블록
- if 참(True) 일때 실행
- elif 앞선 조건이 거짓(false)이고 참 일때 실행
- else > 모든 실행이 거짓일때 실행
- **반복문**
- for문 
- 딕셔너리 순회 - 원칙적으로는 순서가 없지만 python3.7부터 삽입(입력)한 순서대로 나옴
```
abc = [1, 2, 3]
for i in range(len(abc)):
    abc[i] = abc[i] * 2

print(abc) # 2, 4, 6
```
- while 문
- 반드시 종료 조건이 있어야함
- while 조건문
- **반복문**
- 반복제어
- break, continue, pass
- break는 반복문을 **즉시 탈출**
- continue 다음 반복으로 건너뜀
- pass 아무런 작업도 하지않고 넘어감
- for else 구문
```
numbers = [1, 3, 5, 6, 7 ,9, 10 ,11]

for number in numbers:
    if number  % 2 == 0:
        print(f'첫번쨰 짝수 {number}찾음')
else:
    print(못찾음)
```
### 함수
- 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
- 함수 정의는 def 키워드로 시작 (define)
- 함수 이름은 동사 + 명사 로 작성 (make_sum) 컨밴션
- 괄호안에 매개변수를 정의할 수 있다
- **함수 반환 값**
- 함수는 **필요한 경우* 결과를 반환 할수 있음 
- return "반환 값"
- 매개 변수 : 함수를 **정의**할 떄
- 인자 : 함수를 **호출**할 때
- **위치 인자**
- 함수 호출 시 인자의 위치에 따라 전달되는 인자
- 함수에 넣은 인자의 위치에 맞게 들어감
- **기본 인자값**
- 함수 정의단계에서 기본값(default)값을 정해주는것
-  **키워드 인자값**
- 호출시 인자의 이름과 함께 값을 전달하는 인자
- 순서에 상관없이 적용가능
- 호출 시 키워드 인자는 위치 인자 뒤에 위치해야함 (아니면 오류뜸)
- **임의의 인자 목록**
- def adb(*args) <<
- 정해지지 않은 개수의 인자를 처리하는 인자
- list형식이 아닌 tuple 형태로 줌
- 매개변수 앞에 ' * '를 붙여 사용
- **임의의 키워드 인자 목록**
- def adb(**kwargs) 
- 매개변수 앞에 ' ** ' 를 붙여 사용
- dict 형태로 받음
### python의 범위(soope)
- local scope에 존재하기 떄문에 global scope에서는 사용할수 없음
- local에 지정한 변수는 global에서 사용 불가

- built-in scope (print, len 같은 내장함수들)
- 파이썬이 실행된 이후부터 영원히 유지되는 것
- scope의 순서 **LEGB Rule**

### **lisat comprehension** (리스트 한줄로 쓰기)
- 나중에 공부 다하고 코드 줄이기 하고싶을떄 사용
- 속도가 빠르다는 장점이 있음

### enumerate(iterable, start=0)
- enumerate 인덱스와 value값을 동시에 가져올때 사용
```
fruits = ['apple', 'banana', 'cherry']

for ind, va in enumerate(fruits, start=3):
    print(ind, va)
```


- 주석을 생활화 합시다



## 250730
### 함수
- 함수를 실행하기 위해서는 함수를 호출해야함
### socpe(영역)
- if, for문은 socpe를 형성하지 않으
- def, class ,lambda 만 scope를 형성함
### 재귀함수
- 함수 내부에서 자기 자신을 호출하는 함수 (함수안으 함수)
- ex/ 팩토리얼, 
- n이 0이 될 때 까지(작아짐) 반복되며 **무조건 종료조건을 설정**하여 재귀 호출이 멈추도록 해야함
- 반복되느 호출이 종료문을 다가서야함
- 변수의 사용이 줄어듬
- 수학적 문제를 풀기위함(알고리즘)
- 코드의 간결성이 있음
### 내장함수
- min, max, len, sum ,sorted 등
- **map(function, itreable)**
- 순회 가능한 데이터 구조의 모든요소에 함수를 적용하고, map object로 반환
- split -> 공백간격으로 자르는 함수 1 2 3 -> 1, 2, 3
- 휘발성 객체? map object는 이터레이터(iterator)
- 게으른 평가 (lazy evaltuation)
- 명령을 받는 즉시 계사능ㄹ 수행하지 않는다 -> 메모리 효율성과 성능을 위해서
- generator 가 뭐야?
- zip(*몇개가 들어와도 됨)  - 알고리즘 회전때 유용하게 사용
- a_stud/ b_stud zip(a_stud, b_stud) 압축? 합치는것
### 함수 스타일 가이드
- 소문자와 _(언더바) 사용
- 동사 + 명사
- 동사 + 형용사 + 명사
- get/set 접두사
- 약어 사용 지양
### 단일 책임 원칙
- 모든 객체는 하나의 명확한 목적과 책임만을 가져야 함
- 기능은 1개씩만
- 각 기능을 1개씩 만들고 함수를 한번에 만드는 함수를 사용하는게 좋음(유지보수)
- 일단 짜고 나중에 나누기 추천
- **요약 정리**
- 함수는 한 가지 작업만 수행
- 함수 이름으로 목적을 명확히 표현
- 작은 단위의 함수로 요약
### Packing & Unpacking
- packing 
    - 하나의 변수에 묶어서 담는 것
    - *를 활용한 패킹 
    - *로 남은 요소들은 **리스트**로 할당
- unpacking
    - *를 활용한 언패킹
    - *는 리스트의 요소를 언패킹하여 인자로 전달
    - **를 활용한 언패킹
    - 딕셔너리의 키-값 쌍을 언패킹하여 함수의 키워드 인자로 전달
### 모듈(module)
- 혼자 만들기는 힘들기때문에 만들어진 것을 사용
- 효율(재사용 가능) ,안정성(여러번 사용했기 떄문에 검증이 되있다), 확장성이 좋음
- math 내장 모듈(수학 모듈) 
```
impot math
```
- 모듈을 가져오는 방법 : import , from
- 모듈 주의사항
    - 서로 다른 모듈이 같은 이름의 함수를 제공할 경우 문제 발생
    - 마지막의 import된 이름으로 대체딤
- as 키워드를 사용하여 별칭을 부여 가능
- math 처럼 기본 내장 module이 있음
- 모듈을 직접 만들수도 있다
- 같은 폴더가 아니라도 사용가능
- 외부 패키지 pip
```
 import requests
 url = 'https:'
 response = requests.get(url).json()

 print(response)
```
- 주의사항
    - 버전 충돌
    - 라이선스 확인
    - 보안
- 람다 표현신(lambda)
- 익명 함수를 만드는 데 사용되는 표현식 -> 한 줄로 간단하게 
- 한번쓰고 말때 사용
- 함수를 정의
- lambda 매개변수: 표현식\

```
# 내부함수 보는법

import math
print(help(math))
```
## 250730 - 오후
- 데이터 구조 (자료 구조)
- 여러 데이터를 효과적으로 사용,관리하기 위한 구조
- **메서드(method)**
    - 객체에 속한 함수(객체의 상태를 조작하거나 동작을 수행)
    - class 내부에 정의되는 함수
    - 각 데이터 타입별ㄹ로 다양한 기느을 가진 메서드가 존재
```
메서드 호출 방법
변수.함수 .<< 점!이 중요
print('hello'.capitalize()) - 첫글자만 대문자로 바꿔주는 메서드 함수
```
- **문자열 메서드**
- is가 붙어있으면 True,False로 반환됨
    - s.find(x) x의 첫 번쨰 위치(인덱스)를 반환. 없으면 **-1**을 반환
    - s.index(x) x의 첫 번쨰 위치(인덱스)를 반환. 없으면 **오류** 발생
    - s.isupper() 모든 문자가 대문자인지 확인
    - s.islower() 모든 문자가 소문자인지 확인
    - s.isalphaZ() 모든 문자가 알파벳인지 확인
    - s.isdecimal() 모든 문자가 숫자인지 확인 / 쥰내 쓸대없음
    - s.isdigit() 유니코드 숫자도 숫자로 인식 확인
    - s.isnumeric() 저 추가적인 유니코드 숫자도 숫자로 인식확인
- 문자열 조작 메서드
    - s.replace(old, new[,count]) - 글자 바꾸기 old를 new로 바꾸기
    - s.strip([chars]) - 문자열으 시작과 끝에 있는 공백혹은 지정한 문자 제거
    - **s.split**(sep=None, maxsplit=-1) sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트로 반환  - ()안에 있는 문자 기준으로 cut! - 잘려진 위치 단어는 삭제됨
    - 'separator'**.join**(iterable)  iterable의 문자열을 연결한 문자열을 반환(리스트,튜블 딕셔너리 다됨)
    - s.capitalize() - 첫글자를 대문자로
    - s.title() - 각 단어에서 첫글자를 대문자로
    - s.upper() - 모든문자 대문자
    - s.lower() - 모든문자 소문자
    - s.swapcase() - 대소문자 바꾸기
- **리스트 메서드**
    - **L.append(x)** 리스트 마지막에 항목 x를 추가[1, 2, 3 ,[4, 5, 6]]
        - 통으로 다 넣기
    - **L.extend(m)** m의 모든 항목들을 리스트 끝에 추가(+=과 같은기능)[1, 2, 3 , 4, 5, 6]
        - 분해 해서 넣기
    - L.insert(i, x) 인덱스 i 위치에 x항목을 추가 - 끼워넣기
        - 속도 매우 느려짐 앵간해서 사용 X
    - L.remove(x) 리스트에서 X와 일치하는 첫번째 항목 삭제
    - **L.pop** 
        - 속도가 굉장히 빠르다 
    - **L.pop(i)** 지정한 i의 인덱스의 항목을 제거하고 반환, 안 넣으면 마지막 항목 제거
    - L.clear() 리스트의 모든 항목 삭제 
    - L.index(x) x에 해당하는 위치 반환
    - L.count(x) x에 해당하는 항목 개수 세기
        - 찾는 과정이 오래걸림 
    - L.reverse() 순서 반대 (순서 뒤집기)
    - L.sort() 오름차순 정렬 #내림차순 정렬 sort(reverse=True)
    - 파이썬 공식 사이트에서 다양한 메서드 확인 가능
- 가변 / 불변
- 가변 : 내용을 변경할 수 **있는** 객체 : list, dict, set
- 불변 : 내용을 변경할 수 **없는** 객체 : int, float, str, tuple
- 변수를 지정하는것은 새로운 객체를 만드는 것
- 변수는 객체의 **메모리 주소**를 저장 <python 종특
- 얕은복사
    - 슬라이싱 [:] 모든것을 복사하는방법
    - L.copy() 
    - 리스트 안의 리스트는 [1, 2, 3 ,[4, 5, 6]]처럼 중첩 리스트로 있는경우는 주소를 가져오는 것이기 때문에 같이 바뀜 
        - 얕은 복사는 최상위의 존재만 가져오는 것이기 떄문에 그럼
- 깊은복사
    - copy 모듈에서 제공하는 deepcopy() 사용
``` 
    import copy
    new_list = copy.deepcopy(original_list)
    # 얕은 복사의 한계 떄문에 나온 복사법
```
- 
## 250731
- 메서드
- 어딘가(class)에 속해있는 함수
- **딕셔너리 메서드**
    - D.clear() 모든 키/값 제거
    - D.get(key) 키에 연결된 값을 반환 없으면 None
    - D.keys() 키만 모으기
    - D.values() 값만 모으기
    - D.itmes() 키/값 둘다 튜플형태로 모으기
    - D.pop(key) 키를 제거하고 연결된 값을 반환
    - D.setdefault(key) 키와 연결된 값을 반환, 키가 없다면 default와 연결된 키를 딕셔너리에 추가하고 default 반환
    - D.update(new D) new D가 제공하는 키/값 쌍으로 딕셔너리 갱신
        - 기존 키 덮어씌우기/ ( 키는 중복이 안된다 키가 없으면 추가)
    
- **set 메서드**
- **고유**한 항목들의 컬렉션
- 중복을 허용하지 않음
    - s.add(x) 세트에 x항목 추가 / 중복으로 값은 값이 추가되지는 않음 -> set는 고유하기 때문
    - s.clear() 모든항목 제거
    - s.remove(x) 세트에서 x 항목 제거 / 항목이 없으면 eror -> 속도가 빠름, 지워도 재정렬 할 필요가 없음
    - s.pop() 임의의 요소를 제거하고 반환
    - s.discard(x) 세트에서 x항목 제거 / 항목 없어도 error 안뜸
    - s.update(iterable-반복되는것들) 세트에 (반복)항목 추가 
        - **집함 메서드**
        - set1.difference(set2) 차집합 set - set2
        - set1.intersection(set2) 합집합 set1 & set2
        - set1.issubset(set2) set2 부분집합 set1 <= set2
            - 맞으면 True 틀리면 False
        - set1.issuperset(set2) set1 부분집합 set >= set2 
            - 맞으면 True 틀리면 False
        - set1.union(set2) 합집합 set1 | set2
- 메서드 체이닝 : 여러 메스드를 연속해서 호출하는 방식
- 해시 테이블(알고리즘 22일차에 deep<<<<)
    - 해시 함수를 사용하여 index로 삼아 key와 value를 저장하는 자료구조
- 키를 해시함수를 통해 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 데이터를 저장하거나 검색
- **해시**
    - 임의의 크기를 가진 **데이터** 고정된 크기의 **고유한 값**으로 변환하는 것
    - 지문 같은 역활

- **해시 함수**
    - 데이터를 입력받아 **데이터(해시 값)**을 출력하는 함수
    - 해시 테이블 자료구조에 사용되며, 매우 빠른 데이터 검색을 위한 computer sw에서 유용하게 사용
- 똑같은 값이 나올때 <<해시 충돌>> 이라고 한다 (어디선가 들어봄)
- hashable
- 해시 테이블의 키는 **불변해야함!**
- 값이 변경될수 있기 떄문에 가변형 객체는 hashable 하지 않음


- **파이썬 문법 규격**(시험 안나옴)
- BNF : 표기법
- EBNF : 확장한 표기법
    - [] 선택적 요소
    - {} 0번 이상 반복
    - () 그룹화

## 250731 - 오후
- 절차 지향과 객체 지향

- 절차 지향 : 프로그램을 함수와 로직 중심으로 작성
    - 처음부터 끝까지 실행되는 결좌물이 중요
    - 복잡성 증가 
        - 프로그램 규모가 커질수록 **데이터와 함수의 관리가 어려움**
        - 전역 변수의 증가로 인한 **관리가 어려움**
        - 유지 보수 문제 발생(코드가 많이 꼬임)
        - 함수 호출의 흐름이 중요
            - 속도가 빠름 ,설계 복잡도도 낮음, 직관적이다
            - 작고 간단한 프로젝트, 스크립트 에 사용, 유지보수 쉬움
    - 매개변수로 전달되어 처리되는 수동적 존재
- 객체 지향(object)
    - 데이터와 함수를 하나의 **단위**로 묶어서 관리
    - 객체들을 조합하고 재활용하는 방식으로 프로그램 구성
    - 데이터와 메서드를 하나의 객체(클래스)로 묶음
    - **객체 간 상호작용과 메시지 전달이 중요**
            - 유지보수 어려움,재사용하기 쉬움, 협업용
            - 대규모 프로젝트
    - 데이터가 능동적인 객체로 변화
    - 메서드가 하나의 객체로 통합되어 스스로 기능을 수행하는 능동적 존재

- **객체**
    - **속성과 동작(메서드)**을 가짐
    - 각 객체는 고유한 특성을 가짐
- **클래스**
    - 객체를 만들기 위한 **설계도**
    - **데이터와 기능**을 함께 묶는 방법 제공
    - 속성과 메서드를 정의
    - 클래스로부터 여러 개의 객체를 쉽게 찍어낼 수 있음(만들수 있음)
    - 클래스 이름은 **파스칼 케이스** 방식으로 작성 
        - 각 단어의 첫 글자를 대문자로
```
### class MyClass:
    pass
```
- 파이썬은 스네이크 케이스 (소문자, _(언더바)로 함)
    - 생성자 메서드
        - __init__메서드는 '생성자 메서드'로 불리며, 새로운 객체를 만들 떄 **초기값 설정** 할때 사용
        - **인스턴스** : 클래스를 통해 생성된 객체
        - __init__(selt, paramiter) : 처음은 무조건 self

- 클래스 구조
    - 인스턴스 변수
        - 각 인스턴스별 고유한 속성
        - self, 변수명 형태로 정의
        - 인스턴스마다 **독립적인 값 유지**
        
    - 클래스 변수
        - 모든 인스턴스가 공유하는 속성
### 메서드
- 클래스 내부에 정의된 함수로, 객체의 동작 정의
    - 인스턴스 메서드
        - **인스턴스**에서 호출할수 있는 메서드
        - 클래스 내부에 정의되는 메서드
        - 인자로는 **무조건 인스턴스(자기자신)을 처음**으로 받음
            - self는 매개변수라서 변경은 가능하지만 다른이름을 쓰지않는 것을 강력히 권장
        - 객체 지향 방식의 메서드로 호출하는 표현(단축형 호출)
        - 생성자 메서드 -> 인스턴스 메서드 
            - self, 자기자신을 첫번쨰 파라미터로 쓰니깐
            - **인스턴스 변수르 초기화**
                - 인스턴스 상태를 다룬다 <<
        -  인스턴스는 모든 메서드를 호출 할수있지만 **인스턴스 메서드만 사용하자** 알잘딱 하자
    - 클래스 메서드
        - 특정 인스턴스에 속하지 않음
        - 클래스가 호출하는 메서드
        - **클래스 변수를 조작하거나 클래스 레벨의 동작을 수행**
        - **@classmethod 데코레이터** 를 사용하여 인스턴스와 구분함
        - self 대신 cls를 사용(변경 가능하지만 다른이름 사용 x 강력히 권장)
        -  클래스는 모든 메서드를 호출 할수있지만 **가급적이면 클래스 메서드와 스태틱 메서드**만 쓰자
            - 객체 지향을 위행 
    - 스태틱 메서드
        - 클래스와 인스턴스와 상관없이 독립적으로 동작하는 메서드
        - **@staticmethod 데코레이터**를 사용하여 정의
        - 호출 시 자동으로 전달 받는 인자가 없음(self, cls를 받지 않음)
        - 인스턴스나 클래스가 접근하지 않는 **도우미 함수** 역활
        
- 클래스와 인스턴스 간의 이름 공간
    - 인스턴스를 만들면 **독립적인** 이름 공간 (LEGB?랑 비슷 클래스 안에 인스턴스가 있어서 잡아 먹힘)
    - 독립전인 이름공간을 가지는 이점
        - 인스턴스는 독립적인 메모리 공간을 가짐 
            -> 독립적으로 동작 하도록 보장
        - 코드의 가독성,유지보수성, 재사용성을 높이는데 도움을줌

- 매지 메서드( magic method)
- __가 있는 메서드
- __str__ , 

- 데코레이터 **(시험 안나옴)** 알아두기만 해라
    - 다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 함수 

## 250801 - 관통 프로젝트
- git 
    - 분산 버전 관리 시스템
    - 코드의 **변경 이력**을 기록하고 **협업** 하기위한 도구
    - Working Directory
        - 실제 작업 중인 파일 위치
    - Staging Area
        - 다음 버전에 포함시킬 파일 준비 영역
        - commit 목록에 올려놓는 것들
    - Repository
        - git init 
        - 버전 관리 선언
    - Commit : 버전
        - **변경된 파일** 을 저장 / snapshot 이라고도 함
- git add -A
    - working Directory에 있는 모든 빨간색 add 해버리기


    - 
- git add -p
    - add . 과 다르게 내가 올리고 싶은 data를 한번더 확인하고 올릴수 있음
    
- pathlib  
