## 250804
- 알고리즘
  - 문제 해결 능력 UP
  - 논리적 사고 UP
  - 코딩테스트 준비 << 중요
    - 언어 이해 가능한지
    - 논리적인 사고
    - 코딩 스타일
    - 에러 처리를 어떻게 하는지
    - 최적화능력
    - 커뮤니케이션(주석 사용 능력)
- 자료구조와 알고리즘
### 알고리즘
- **문제를 해결하기** 위한 절차나 **방법**
- 알고리즘 유형은 크게 3가지
  - 의사코드(슈도코드, Pseudocode) 와 순서도, 그리고 프로그래밍 언어
    - 의사코드 : 자연어와 프로그래밍 언어의 중간
  - 좋은 알고리즘이란
      - 정확성 : 얼마나 정확하게 동작하는가
      - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
      - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
      - 단순성 : 얼마나 단순한가
      - 최적성 : 더 이상 개선할 여지없이 최적화되었는가
    - **시간복잡도**
    - 알고리즘의 작업량을 표현할 떄 **시간복잡도** << 를 사용
        - **빅-오 표기법(Big-O Noatation)**
          - 알고리즘이 가장 느리게 실행될 때의 성능(최악의 성능)
          - 함수 중에서 **가장 큰 영향력을 주는 n**만 표시
          - **계수(Coefficient)는 생략**
            - O(2n제곱 + 10n + 100) = (계수생략) O(n제곱)
      - 문제가 난이도가 높고 확신이 없으면 시간복잡도 부터 구해야한다
          - 1억이 넘어가면 파라미터 서치 사용
       
        - 최선의 경우(Best case) 빅 오메가 : 알고리즘의 잠재능력을 보고싶을때
        - 평균적인 경우(빅 세타) : 일반적인 알고리즘의 성능
      - **공간 복잡도** : 메모리 사용량
- **1차원 리스트**
  - 하나의 선언을 통해 둘 이상의 변수를 선언할수 있다 (배열= 다른 언어 체계에서는 배열이라고 함)
  - 리스트안에 리스트가 없는경우를 1차원 리스트 라고함
  - *(애스터리스크)는 시퀀스에서 반복을 말한다
  - arr = [0]*10 -> [0,0,0,0,0,0,0,0,0,0,0]

- 문제 풀떄 pycharm 사용할것 ->
- 알고리즘 문제플 풀기 위한 단계
   - 1.문제를 읽고 입력 데이터의 범위를 확인한다
   - 2. 입력 데이터의 범위에 맞는 알고리즘을 선택한다
   - 3. 코드 작성전에 **노트에 풀이를 구상한다**
   - 4. 구상한 풀이를 코드로 작성한다
   - 5. 디버깅 하면서 코드 검증
## 250805
### 정렬
- 2개 이상의 자료를 특정 **기준**에 의해 오름차순, 또는 내림차순 하는것
- 버블 정렬
  - 인접합 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  - **첫 번째 원소부터 인접합 원소**끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동
    - 이 과정을 반복하는 과정
    - N(N-1)/2 == N^2
    - 안정성 O : **동일한 키** 값을 가지는 요소의 **상대적 순서 보존**하는지
    - 적응성 O : 초기 정렬 다음에 -> 속도가 바뀌는지
    - 제자리 정렬 O : 외부 메모리를 쓰는 지 (버블정렬 : 외부메모리 사용 X)
```
def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [55, 7, 78, 12, 42]
print(bubble_sort(arr)) # [7, 12, 42, 55, 78]
```
- 선택 정렬
  - 선택하여 정렬하기
  - 주어진 리스트 중에서 **최소값**을 찾는다(찾은 값을 맨 앞에다가)
    - 이 과정 반복
    - N^2
    - 안정성 X 
    - 적응성 X
    - 제자리 정렬 O
```
def selection_sort(arr):
    n = len(arr)

    for i in range(n-1):
        min_idx = i

        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [55, 7, 78, 12, 42]
print(selection_sort(arr)) # [7, 12, 42, 55, 78]
```
- 삽입 정렬
    - 리스트를 정렬/미정렬로 나누고, 미정렬 된 부분의 원소를 **정렬된**부분의 올바른 위치에 삽입
    - 정렬되지 않은 부분집합 U에서 하나씩 꺼내서 정렬 되있는 부분집합 S의 **마지막원소**부터 비교하면서 올바른 위치에 삽
- 카운팅 정렬
- 퀵 정렬
- 병합 정렬
- 
