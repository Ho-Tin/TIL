## 250804
- 알고리즘
  - 문제 해결 능력 UP
  - 논리적 사고 UP
  - 코딩테스트 준비 << 중요
    - 언어 이해 가능한지
    - 논리적인 사고
    - 코딩 스타일
    - 에러 처리를 어떻게 하는지
    - 최적화능력
    - 커뮤니케이션(주석 사용 능력)
- 자료구조와 알고리즘
### 알고리즘
- **문제를 해결하기** 위한 절차나 **방법**
- 알고리즘 유형은 크게 3가지
  - 의사코드(슈도코드, Pseudocode) 와 순서도, 그리고 프로그래밍 언어
    - 의사코드 : 자연어와 프로그래밍 언어의 중간
  - 좋은 알고리즘이란
      - 정확성 : 얼마나 정확하게 동작하는가
      - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
      - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
      - 단순성 : 얼마나 단순한가
      - 최적성 : 더 이상 개선할 여지없이 최적화되었는가
    - **시간복잡도**
    - 알고리즘의 작업량을 표현할 떄 **시간복잡도** << 를 사용
        - **빅-오 표기법(Big-O Noatation)**
          - 알고리즘이 가장 느리게 실행될 때의 성능(최악의 성능)
          - 함수 중에서 **가장 큰 영향력을 주는 n**만 표시
          - **계수(Coefficient)는 생략**
            - O(2n제곱 + 10n + 100) = (계수생략) O(n제곱)
      - 문제가 난이도가 높고 확신이 없으면 시간복잡도 부터 구해야한다
          - 1억이 넘어가면 파라미터 서치 사용
       
        - 최선의 경우(Best case) 빅 오메가 : 알고리즘의 잠재능력을 보고싶을때
        - 평균적인 경우(빅 세타) : 일반적인 알고리즘의 성능
      - **공간 복잡도** : 메모리 사용량
- **1차원 리스트**
  - 하나의 선언을 통해 둘 이상의 변수를 선언할수 있다 (배열= 다른 언어 체계에서는 배열이라고 함)
  - 리스트안에 리스트가 없는경우를 1차원 리스트 라고함
  - *(애스터리스크)는 시퀀스에서 반복을 말한다
  - arr = [0]*10 -> [0,0,0,0,0,0,0,0,0,0,0]

- 문제 풀떄 pycharm 사용할것 ->
- 알고리즘 문제플 풀기 위한 단계
   - 1.문제를 읽고 입력 데이터의 범위를 확인한다
   - 2. 입력 데이터의 범위에 맞는 알고리즘을 선택한다
   - 3. 코드 작성전에 **노트에 풀이를 구상한다**
   - 4. 구상한 풀이를 코드로 작성한다
   - 5. 디버깅 하면서 코드 검증
## 250805
### 정렬
- 2개 이상의 자료를 특정 **기준**에 의해 오름차순, 또는 내림차순 하는것
- 버블 정렬
  - 인접합 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  - **첫 번째 원소부터 인접합 원소**끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동
    - 이 과정을 반복하는 과정
    - N(N-1)/2 == **O(N^2)**
    - 안정성 O : **동일한 키** 값을 가지는 요소의 **상대적 순서 보존**하는지
    - 적응성 O : 초기 정렬 다음에 -> 속도가 바뀌는지
    - 제자리 정렬 O : 외부 메모리를 쓰는 지 (버블정렬 : 외부메모리 사용 X)
```
def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [55, 7, 78, 12, 42]
print(bubble_sort(arr)) # [7, 12, 42, 55, 78]
```
- 선택 정렬
  - 선택하여 정렬하기
  - 주어진 리스트 중에서 **최소값**을 찾는다(찾은 값을 맨 앞에다가)
    - 이 과정 반복
    - **O(N^2)**
    - 안정성 X 
    - 적응성 X
    - 제자리 정렬 O
```
def selection_sort(arr):
    n = len(arr)

    for i in range(n-1):
        min_idx = i

        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [55, 7, 78, 12, 42]
print(selection_sort(arr)) # [7, 12, 42, 55, 78]
```
- 삽입 정렬
    - 리스트를 정렬/미정렬로 나누고, 미정렬 된 부분의 원소를 **정렬된**부분의 올바른 위치에 삽입
    - 정렬되지 않은 부분집합 U에서 하나씩 꺼내서 정렬 되있는 부분집합 S의 **마지막원소**부터 비교하면서 올바른 위치에 삽입
    - **O(N^2)**
    - 안정성 O
    - 적응성 O
    - 제자리 정렬 O
```
def insertion_sort(arr):
    n = len(arr)

    for idx in range(1, n):         # 위치 찾기
        for jdx in range(idx, 0, -1):       # 비교 하기
            if arr[jdx - 1] > arr[jdx]:
                arr[jdx-1], arr[jdx] = arr[jdx], arr[jdx-1]
            else:
                break
    return arr

arr = [55, 7, 78, 12, 42]
print(insertion_sort(arr)) # [7, 12, 42, 55, 78] 
```
- 카운팅 정렬
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, **선형 시간**O(N)에 정렬하는 효율적인 알고리즘
    - **정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능**
    - 최대값을 알아야 한다
    - 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열
    - **O(n+k)**
    - 막 정렬하면 안정성이 없다 -> 누적합 배열 -> 각 원소가 어디에 놓일수 있는지 확인
    - 안정성 O
    - 적응성 X
    - 제자리 정렬 X
```
def counting_sort(arr, max_value): #최대값 찾기 - max_value로 파라미터 제공중 / 조건식 만들던가 max로 쓰던가 알아서 찾을것
    n = len(arr)
    count_arr = [0] * (max_value + 1)

    for num in arr:
        count_arr[num] += 1

    # 안정성을 지키기 위해 누적합 배열 작성( 누적합 배열 : 해당 값이 들어갈 수 있는 범위)
    for i in range(1, len(count_arr)):
        # 이전 값을 누적해서 스스로 갱신
        # 이전 값은 이미 이전 값들을 누적한 상태이므로 가능한 방법
        count_arr[i] += count_arr[i-1]

    result = [0] * n
    # 주어진 배열을 거꾸로 순회하면서, 누적합 배열의 값을 이용해 값을 넣는다
    for i in range(n-1, -1, -1):   # 역으로 순회
        val = arr[i]    #arr[i] 너무 길어서 val로 편하게 쓸라고 적음

        result[count_arr[val] - 1] = val
        count_arr[val] -= 1

    return result

arr = [0, 4, 1, 3, 1, 2, 4, 1]
result =counting_sort(arr, 4)
print((result))
```

- 퀵 정렬
- 병합 정렬
- 
