# 트리
  - **비선형** 구조
  - 원소들 간에 **1:n**관계를 가지는 자료구조
  - **계층형 자료구조**
  - 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조
- 한 개 이상의 노드로 이루어진 유한 집합
  - 노드 중 최상위 노드를 루트(root)라 한다
    - 루트는 1개만 존재 할 수 있음
  - 루트 밑에 subtree 라고 함
  - 밑에 노드가 없으면 단말노드 또는 잎(leaf) 노드라고 함
### 트리 용어
- 노드(node)
  - 트리의 원소
- 간선(edge)
  - 노드와 노드를 연결하는 선
  - 부모 노드와 자식 노드를 연결
- 루트 노드(root node)
  - 트리의 시작 노드인 최상위 노드
- 형제 노드(sibling node)
  - 같은 부모 노드의 자식 노드들
- 조상 노드(ancestor node)
  - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리(subtree)
  - 부모 노드와 연결된 간선을 끊었을 떄 생성되는 트리
- 자손 노드(descendant node)
  - 서브 트리에 있는 하위 레벨의 노드들
- **차수(degree)**
  - 노드의 차수
    - 노드에 연결된 자식 노드 수
  - 트리의 차수
    - 트리에 있는 노드의 차수 중에서 **가장 큰 값**
  - 단말 노드(leaf node)
    - 차수가 0인 노드, 자식이 없는 노드
- 레벨
  - 루트에서 노드까지의 거리
- 높이
  - 루트 노드에서 가장 먼 리프 노드까지의 간선
### 이진 트리
- 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
- 포화 이진 트리(perfect Binary Tree)
  - 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 완전 이진트리(Complete Binary Tree)
  - 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 편향 이진 트리(Skewed Binary Tree)
  - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리
### 이진 트리 표현 : 리스트
1. 이진 트리에 각 노드 번호를 부여
2. 루트 노드를 1로 설정
3. 왼쪽부터 번호 부여( 빈공간이 있어도 번호를 부여)
  - 노드 번호가 i일 때
    - 부모 노드 번호 : i/2
    - 왼쪽/오른쪽 자식 노드 번호 : 2*i, 2*i+1
- 노드 번호를 리스트의 인덱스로 사용
- 연결 리스트로 구현 가
### 이진 트리 순회
- 순회
  - 전위순회 (pre-order traversal)
    - 부모 -> 좌 -> 우
    - 용어 기준 : 루트 노드
  - 중위순회 (in-order traversal)
    - 좌 -> 부모 -> 우
  - 후위순회 (post-order traveral)
    - 좌 -> 우 -> 부모
### DFS, BFS
- DFS(깊이 우선 탐색)
- BFS(너 우선 탐색)
### 그래프
- 비선형 구조
- 아이템 들과 이들 사이의 연결 관곌르 표현한다
- N:M 관
- 정점(vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
  - 정점(vertex): 그래프의 구성요소로 하나의 연결점
  - 간선(Edgq) : 두 정점을 연결하는 선
  - 차수(Degree) : 정점에 연결된 간선의 수
- V개의 정점을 가지는 그래프는 최대 V*(V-1)/2 간선 수
### 그래프 유형
- <img width="2074" height="792" alt="image" src="https://github.com/user-attachments/assets/d9930fb4-f3d6-4436-a67c-1998d8a18fa0" />
- 무방향 그래프(Undirected Graph)
- 방향 그래프(Directed Graph) : 진입차수, 진출차수 
- 가중치 그래프(Weighted Graph)
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)
- 완전 그래프
- 부분 그래프
- 인접(Adjacency)
  - 두 개의 정점에 간선이 존재하면 서로 인접해 있다고 함
- 싸이클(Cycle)
  - 경로의 시작 정점과 끝 정점이 같음
### 그래프 표현
- 인접 행렬
  - V*V 크기의 2차원 배열을 이용해서 간선 정보를 저장
  - 두 정점을 연결하는 간선의 유무를 행렬로 표현
    - V*V 정방 행렬(행 과 열의 수가 같은 행렬)
    - 두 정점이 인접되어 있으면 1, 아니면 0으로 표현
  - 장점
    - 연산 속도 O(1)로 빠름
    - 구현이 단순
    - 정적 그래프에 적합
  - 단점
    - 많믄 메모리를 차지함(공간 복잡도: O(V2))
    - 간선 수를 확인하거나 인접한 정점을 나열하는 연산이 느림
  - 사용하기 좋은 상황
    - Dense Graph(밀집그래프)에 적합
    - 두 정점 사이에 간선이 있는 지 빠르게 확인해야 하는 경우
- 인접 리스트
  - 각 정점에 대한 인접 정점들을 순차적으로 표현
  - 장점
    - 필요한 공간만 사용하므로 공간 복잡도O(V+E)
    - **인접한 장점을 나열하는 연산이 빠름**
  - 단점
    - 두 정점 사이에 간선이 있는 지 확인하느 연산이 느림(O(V))
    - 링크드리스트로 구현이 복잡
  - 사용하기 좋은 상황
    - Sparse Graph(희소 그래프)에 적합
    - 그래프가 동적으로 변하는 경우(정점과 간선이 자주 추가/삭제)
    - 인접한 정점을 자주 순회해야 하는 경우
- 간선 리스트
  - 두 정점에 대한 간선 그 자체를 객체로 표현하여 리스트로 저장
  - 장점
    - 공간 복잡도 O(E)
  - 단점
    - 두 정점 사이에 간선이 있는 지 확인하는 연산이 느림 / 시간 복잡도 O(E)
    - 특정 정점에 인접한 정점을 찾는 연산이 느림
  - 사용하기 좋은 상황
    - 간선 중심 연산을 자주 수행해야 하는 경우(MST)
### DFS(그래프)
- 시작 정점
- 방문처리(vistied) 필수
### BFS(트리)
- 루트 노드의 자식 노드들을 먼저 모두 차례로 탐색
1. 큐를 만듬 (Deque)
2. 루트를 삽입
3. 큐가 빌때까지 while문
4. 첫번째 원소부터 반환
5. 큐의 자식이 비어있을떄의 코드도 작성 필요
### BFS(그래프)
### 백트레킹
- 가지치기
- 해를 찾는 도중 막히면(해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법이다.
- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식으로 가는 방식(backtraking)
- 
