# 문자열 패턴 매칭 알고리즘 정리

문자열 패턴 매칭 알고리즘은 텍스트 문자열 내에서 특정 패턴(문자열)을 효율적으로 탐색하기 위해 사용된다. 대표적인 알고리즘으로는 **브루트 포스(Brute Force)**, **라빈-카프(Rabin-Karp)**, **보이어-무어(Boyer-Moore)**, **KMP(Knuth-Morris-Pratt)** 알고리즘이 있다.  

---

## 브루트 포스 패턴 매칭 알고리즘
- **아이디어**: 텍스트의 첫 문자부터 끝까지 하나씩 차례대로 패턴과 비교하며 탐색한다.
- **방법**
  1. 텍스트의 위치를 하나씩 이동하면서 패턴 전체 문자열과 비교한다.
  2. 모든 문자가 일치하면 패턴이 존재하는 위치를 반환한다.
  3. 불일치하면 다음 위치로 이동한다.
- **시간 복잡도**
  - 최악의 경우: \( O(m \times n) \)  
    (텍스트 길이 \(n\), 패턴 길이 \(m\))
- **장점**: 구현이 간단하다.
- **단점**: 효율성이 떨어져 긴 문자열에서는 느리다.

---

## 라빈-카프 알고리즘 (Rabin-Karp)
- **아이디어**: 문자열 비교 대신 해시값을 비교하여 탐색 속도를 높인다.
- **방법**
  1. 패턴의 해시값을 계산한다.
  2. 텍스트의 부분 문자열을 이동하면서 해시값을 구한다.
  3. 해시값이 패턴과 같으면 실제 문자열을 직접 비교하여 패턴 일치를 확인한다.
- **시간 복잡도**
  - 평균: \( O(n + m) \)
  - 최악: \( O(m \times n) \) (모든 해시 충돌 발생 시)
- **장점**
  - 다중 패턴 탐색이 가능하다.
  - 평균적으로 빠른 탐색이 가능하다.
- **단점**
  - 해시 충돌이 발생할 수 있다.
  - 해시 함수 설계가 중요하다.

---

## 보이어-무어 알고리즘 (Boyer-Moore)
- **아이디어**: 패턴을 뒤에서 앞으로 탐색하여 **불일치 발생 시 점프**를 활용해 탐색 횟수를 줄인다.
- **사용 원리**
  - **Bad Character Rule (나쁜 문자 규칙)**:
    불일치한 문자가 패턴에 존재하지 않으면 패턴을 통째로 오른쪽으로 이동시킨다.
  - **Good Suffix Rule (좋은 접미사 규칙)**:
    불일치가 발생했을 때, 이미 맞은 접미사가 패턴의 어디에 또 나타나는지 확인해 점프한다.
- **시간 복잡도**
  - 평균적으로 매우 빠르며 \( O(n/m) \)까지 향상될 수 있음.
  - 최악의 경우 \( O(m \times n) \).
- **장점**
  - 실제 상황에서 가장 빠르게 동작하는 경우가 많다.
  - 불일치가 발견되면 많은 문자를 건너뛸 수 있다.
- **단점**
  - 구현이 복잡하다.

---

## KMP 알고리즘 (Knuth-Morris-Pratt)
- **아이디어**: 이미 비교한 정보를 재활용하여 **불필요한 이동을 줄이는 방식**.  
  패턴 내에서 실패가 발생했을 때, 패턴의 접두사와 접미사가 일치하는 부분을 활용하여 점프한다.
- **방법**
  1. **부분 일치 테이블(Partial Match Table, LPS 배열)**을 만든다.  
     → 패턴의 접두사와 접미사가 일치하는 최대 길이를 저장.
  2. 불일치 발생 시, 이전 비교 위치에서 LPS 배열 값을 참고하여 건너뛴다.
- **시간 복잡도**
  - 전처리(LPS 배열 생성): \( O(m) \)
  - 탐색: \( O(n) \)
  - 전체: \( O(n + m) \)
- **장점**
  - 최악의 경우에도 선형 시간 성능 보장.
  - 불필요한 비교를 줄인다.
- **단점**
  - 구현이 브루트 포스보다 복잡하다.
  - 실제 평균 속도는 보이어-무어보다 느릴 수도 있다.

---

## 알고리즘 비교 표

| 알고리즘       | 시간 복잡도 (최악) | 시간 복잡도 (평균) | 장점 | 단점 |
|----------------|-------------------|--------------------|------|------|
| 브루트 포스    | \( O(m \times n) \) | \( O(m \times n) \) | 구현 간단 | 긴 문자열에서 느림 |
| 라빈-카프      | \( O(m \times n) \) | \( O(n + m) \) | 해시 사용, 다중 패턴 가능 | 해시 충돌 가능 |
| 보이어-무어    | \( O(m \times n) \) | 매우 빠름 (\(O(n/m)\)까지 기대) | 실제 환경에서 가장 빠름 | 구현 복잡 |
| KMP            | \( O(n + m) \) | \( O(n + m) \) | 최악의 경우도 선형 보장 | 구현 복잡, 평균 속도는 보이어-무어보다 느릴 수 있음 |

---
