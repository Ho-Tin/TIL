# 이진 탐색 트리
- 대량의 데이터를 다루게 되면서 데이터를 효율적으로 저장, 검색, 수정하는 것이 중요
- 선형 데이터 구조의 한계
  - 배열: 데이터 삽입/삭제가 비효율적(O(n))
  - 연결 리스트: 검색이 비효율적(O(n))
  - 데이터의 양이 많아질수록 성능이 저하됨
## BST(이진 탐색 트리)
- Binary Search Tree
- 데이터의 저장, 검색, 삽입, 삭제를 효율적으로 처리하기 위한 자료구조
- 특징
  - 각 노드가 **최대 2개의 자식**을 가짐
  - 데이터를 정렬된 형태로 저장하여 탐색/삽입/삭제를 효율적으로 수행
- 구조
  - 이진 트리의 특성을 가지지만 추가로 **순서속성**을 가짐
    - 왼쪽 자식 노드의 키 값이 부모 노드의 키 값보다 작다
    - 오른쪽 자식 노드의 키 값이 부모 노드의 키 값보다 크다
- 장점
  - 배열이나 링크드 리스트와 달리, 삽입/삭제 후에도 데이터가 정렬된 상태를 유지
  - 데이터가 균형 있게 분포되어 있을 떄 시간복잡도 O(logN)
- 단점
  - 트리가 한쪽으로 치우치면, 시간복잡도가 O(n)이 될 수 있음
- 주요 연산: 탐색
  - 순서 속성을 이용하여 루트노드->  왼쪽 또는 오른쪽 자식으로 이동하면서 키 값을 비교하여 주어진 키 값을 찾는 과정
- 주요 연산: 삽입
  - 삽입할 위치를 찾기 위해 루트 노드에서부터 적절한 위치까지 내려감
  - 트리의 순서 속성을 유지하기 위해서 새로운 노드는 리프 노드로 삽
- 주요 연산: 삭제
  - 삭제하려는 노드의 위치와 자식 노드의 유무에 따라 세가지 경우로 나누어 처리
    - 리프 노드인 경우 : 단순히 탐색하고 제거
    - 한개의 자식 노드를 가질 경우 : 자식노드를 부모 노드에 연결
    - 두개의 자식 노들르 가질 경우 : **중위 후속자 또는 중위 전임자** 찾기
      - **중위 후속자** : 삭제할 노드의 오른쪽 서브 트리에서 가장 작은 값(일반적으로 사용)
      - 중위 전임자 : 삭제할 노드의 왼쪽 서브 트리에서 가장 큰 값
      - BST 구조를 유지하기 위해서 삭제할 노드와 가장 가까운 값을 찾는 것
- 정리
## 힙(heap)
- 완전 이진 트리에 있는 노드중 가장 작은 노드를 찾기위해서 만든 자료 구
- 주요 연산: 삽입
  - 새로운 원소를 heap의 마지막 위치에 추가
  - 새로 추가된 원소를 부모 노드와 비교하며, 힙 속성을 만족할 때가지 위로 올
- 주요 연산: 삭제
  - 루트 노드의 원소만을 삭제할 수 있음
- heapq 모듈
  - heapq.heapify(x) : 리스트 x를 heap으로 변환
  - heapq.heappush(heap, item): item을 heap에 추가
  - heapq.heappop(heap): heap에서 가장 작은 원소를 pop 하고 리
