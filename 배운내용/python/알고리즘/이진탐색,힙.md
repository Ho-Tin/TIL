# 이진 탐색 트리(BST)와 힙(Heap)

## 선형 데이터 구조의 한계
- **배열**: 데이터 삽입/삭제가 비효율적 (시간복잡도 O(n))
- **연결 리스트**: 검색이 비효율적 (시간복잡도 O(n))
- 데이터의 양이 많아질수록 성능 저하 발생

---

## 이진 탐색 트리 (Binary Search Tree, BST)

### 특징
- 각 노드는 **최대 2개의 자식**을 가짐
- **순서 속성**을 만족
  - 왼쪽 자식 노드 < 부모 노드
  - 오른쪽 자식 노드 > 부모 노드
- 데이터가 정렬된 형태로 저장되어 탐색, 삽입, 삭제가 효율적

### 장점
- 삽입/삭제 후에도 데이터가 정렬 상태 유지
- 데이터가 균형 있게 분포되어 있을 때 **시간 복잡도 O(logN)**

### 단점
- 트리가 **한쪽으로 치우친 경우** 시간 복잡도가 O(n)까지 증가 가능

### 주요 연산

#### 탐색
- 루트 노드에서 시작하여 키 값을 비교
- 찾고자 하는 값이 작으면 왼쪽, 크면 오른쪽으로 이동

#### 삽입
- 루트부터 탐색하여 적절한 위치에 새 노드를 삽입
- 항상 **리프 노드 위치**에 삽입해야 BST 속성 유지 가능

#### 삭제
삭제할 노드의 자식 수에 따라 3가지 상황 발생:
1. **리프 노드**: 단순히 제거
2. **자식이 1개인 경우**: 자식 노드를 부모에 연결
3. **자식이 2개인 경우**:
   - **중위 후속자**: 오른쪽 서브트리에서 가장 작은 값 (일반적으로 사용)
   - **중위 전임자**: 왼쪽 서브트리에서 가장 큰 값
   - 삭제할 노드를 대체하여 BST 속성 유지

---

## 힙 (Heap)

### 개요
- 완전 이진 트리 기반 자료구조
- 부모 노드가 항상 자식 노드보다 작거나 큼 (최소 힙 / 최대 힙)
- **최대/최소값을 효율적으로 추출**하기 위해 사용

### 주요 연산
- **삽입**
  - 새 원소를 힙의 마지막 위치에 삽입
  - 부모 노드와 비교해 힙 속성을 만족할 때까지 위로 이동
- **삭제**
  - 루트 노드(최대/최소 원소)만 삭제 가능
  - 마지막 원소와 교체 후 힙 속성이 유지되도록 재정렬

### Python heapq 모듈
- `heapq.heapify(x)` : 리스트 `x`를 힙 구조로 변환
- `heapq.heappush(heap, item)` : 힙에 원소 `item` 추가
- `heapq.heappop(heap)` : 힙에서 가장 작은 원소 제거 및 반환
