# 동적 계획법 (Dynamic Programming, DP)

동적 계획법은 **중복되는 부분 문제(Overlapping Subproblems)**를 해결하고, **최적 부분 구조(Optimal Substructure)**를 이용하여 문제를 효율적으로 해결하는 알고리즘 기법이다.  
큰 문제를 작은 문제로 나누어 해결하고, 그 결과를 재사용함으로써 중복 계산을 줄일 수 있다.

---

## 메모이제이션 (Memoization)

- **하향식 접근 (Top-down)** 방법
- 이미 계산한 값을 **메모리에 저장**해 두고, 다시 필요할 때 꺼내어 사용
- **재귀 호출을 기반**으로 구현되며, 중복 계산을 방지
- **장점**
  - 코드 구현이 직관적이고 간단
  - 불필요한 계산을 피하여 실행 속도 향상
- **단점**
  - 추가적인 메모리 공간이 필요
  - 재귀 호출에 의해 **스택 오버플로우(Stack Overflow)** 발생 가능성

---

## DP (상향식, Bottom-up)

- 작은 부분 문제부터 차례대로 해결하면서 큰 문제를 해결
- 이미 해결된 부분 문제들의 해를 `table` (배열/리스트 등)에 저장하며 점진적으로 정답을 도출
- **특징**
  - **중복 부분 문제 구조 (Overlapping Subproblems)**  
    동일한 작은 문제의 해가 여러 번 사용됨
  - **최적 부분 구조 (Optimal Substructure)**  
    문제의 해가 최적인 경우, 그 해를 구성하는 작은 문제들의 해 역시 최적
- **구현 방법**
  - 반복문 기반의 접근 (재귀함수 대신 사용)
  - 점화식(Recurrence Relation)을 기반으로 단계별로 해를 구함
- **장점**
  - 재귀 호출이 없으므로 **스택 오버플로우 위험 없음**
  - 실행 흐름이 명확하고 메모리 관리가 효율적
- **단점**
  - 테이블 크기가 입력 범위에 따라 커질 수 있음
  - 메모이제이션 방식보다 직관성이 떨어질 수 있음

---

## DP와 그리디 알고리즘 비교

| 구분       | 동적 계획법 (DP)       | 그리디 알고리즘 (Greedy) |
|------------|------------------------|--------------------------|
| 접근 방식  | 부분 문제들을 모두 해결 후 종합 | 매 순간 최적의 선택을 함 |
| 최적해 보장 | 항상 보장됨            | 항상 보장되지 않음      |
| 요구 조건  | 중복 부분문제 + 최적 부분구조 필요 | 단순 국소적 선택이 전체 최적이 되는 경우 |

---

## 이항 계수 (Binomial Coefficient)

**이항 계수** \( nCk \)는 **조합 (Combination)** 문제를 해결할 때 자주 사용되며, 다음과 같이 정의된다.

\[
\binom{n}{k} = \frac{n!}{k!(n-k)!}
\]

또는 점화식을 이용해 구할 수 있다.

\[
\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}
\]

- 초기 조건
  - \(\binom{n}{0} = 1\)
  - \(\binom{n}{n} = 1\)

이 점화식은 **파스칼의 삼각형 (Pascal's Triangle)** 과 동일하며, DP를 통해 효율적으로 구현할 수 있다.

---

## 예시: 파스칼의 삼각형

`파스칼의 삼각형`은 각 항이 자신의 바로 위 두 항의 합으로 구성된 삼각형이다.

