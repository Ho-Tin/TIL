서로소 집합(Disjoint-set)은 주로 *집합의 분리 여부 판별*이나 *원소들이 같은 집합에 속하는지*를 효율적으로 처리하기 위해 사용하는 자료구조이다. 이 구조는 특히 그래프 알고리즘(예: Kruskal MST)에서 많이 쓰인다. 기본적으로 `make_set`, `find_set`, `union` 세 가지 연산을 중심으로 작동하며, **대표자(representative, root)**를 통해 집합을 구분한다.  

***

### 서로소 집합(Disjoint Set)의 개념
- **서로소 집합**: 두 집합이 공통 원소를 가지지 않을 때, 즉 교집합이 공집합(∅)일 때 두 집합은 서로소라고 한다.  
- 여러 원소들이 속한 집합을 묶어 관리할 때, 각 집합은 *하나의 대표자 원소*로 구분한다.  
- Disjoint-set 자료구조는 **트리 형태**로 집합을 표현하고, 각 트리의 루트(root)가 그 집합의 대표자가 된다.  

***

### 핵심 연산
#### 1. make_set(x)  
- 원소 `x` 하나만 포함하는 새로운 집합을 생성한다.  
- 보통 노드마다 자기 자신을 부모로 가지게 초기화한다.  
- 예: `parent[x] = x`  

#### 2. find_set(x)  
- 원소 `x`가 어떤 집합에 속하는지를 알아내기 위해 *대표자(root)*를 찾는 연산.  
- 트리 구조에서 `x`의 루트를 따라가며 탐색한다.  
- **경로 압축(Path Compression)** 최적화를 적용할 수 있다.  
  - 경로 압축: 탐색 과정에서 만난 모든 노드를 루트에 직접 연결시켜, 이후 탐색이 빠르게 일어나도록 만드는 방법.  

#### 3. union(x, y)  
- 두 원소 `x`, `y`가 속한 집합을 하나의 집합으로 합친다.  
- 보통 두 집합의 대표자를 찾아 하나의 루트로 연결한다.  
- **Union by rank(또는 size)** 최적화를 적용할 수 있다.  
  - 각 집합의 높이(rank)나 크기를 기준으로 더 작은 트리를 큰 트리에 붙인다.  
  - 이렇게 하면 트리의 높이가 깊어지는 것을 막아 효율성을 높일 수 있다.  

***

### 시간 복잡도
- 단순 구현 시 `find_set`은 O(N)이 걸릴 수 있다.  
- 하지만 **경로 압축(Path Compression)** + **Union by Rank**를 함께 적용하면 거의 상수 시간(아커만 함수 Inverse, $$O(\alpha(N))$$)에 수행 가능하다.  
- 실질적으로 N이 수십억이어도 $$\alpha(N) \leq 5$$이므로 매우 빠른 성능을 낸다.  

***

### 예시 (Python 의사코드)

```python
# 초기화
parent = {}
rank = {}

def make_set(x):
    parent[x] = x
    rank[x] = 0

def find_set(x):
    if parent[x] != x:   # 루트가 아니라면
        parent[x] = find_set(parent[x])  # 경로 압축
    return parent[x]

def union(x, y):
    rootX = find_set(x)
    rootY = find_set(y)
    
    if rootX != rootY:
        # Rank(트리 높이)를 기준으로 합치기
        if rank[rootX] < rank[rootY]:
            parent[rootX] = rootY
        elif rank[rootX] > rank[rootY]:
            parent[rootY] = rootX
        else:
            parent[rootY] = rootX
            rank[rootX] += 1
```

***

### 활용 사례
- **그래프 알고리즘**
  - Kruskal 알고리즘(최소 신장 트리)에서 간선을 추가할 때 사이클이 생기는지 판별하는 데 사용.
- **네트워크 연결 검사**
  - 두 노드가 같은 네트워크에 속해 있는지 확인.
- **그룹화 문제**
  - 집단, 관계 네트워크, 집합 분류 문제에서 집합 관리.

***

서로소 집합은 단순한 자료구조이지만, 경로 압축과 Union by Rank를 적용하면 **거의 O(1)** 성능으로 동작하기 때문에 알고리즘 문제 풀이에서 매우 자주 쓰인다.  

***

# 최소 신장 트리 (Minimum Spanning Tree, MST)

## 1. 신장 트리 (Spanning Tree)
- 정의: 그래프의 모든 정점을 포함하면서 사이클이 없는 **트리 형태의 부분 그래프**
- 특징:
  - n개의 정점을 가지는 무향 그래프의 신장 트리는 항상 **n-1개의 간선**을 가짐
  - 모든 정점이 연결되어 있어야 함
  - 간선의 가중치와는 무관, 단순히 연결성과 사이클 유무만 고려

---

## 2. 최소 신장 트리 (Minimum Spanning Tree)
- 정의: 가중치가 있는 무향 그래프에서 신장 트리를 구성하는 간선들의 가중치 합이 최소가 되는 트리
- 특징:
  - 한 그래프에 최소 신장 트리는 **여러 개 존재할 수 있음**
  - 사이클은 반드시 존재하지 않음
  - 가중치가 동일하지 않으면 MST는 유일하게 결정됨

---

## 3. MST를 구하는 대표 알고리즘

### Kruskal 알고리즘
- 아이디어: **간선을 정렬하여 가중치가 낮은 순으로 추가하면서 MST를 만든다.**
- 동작 과정:
  1. 모든 간선을 가중치 기준으로 오름차순 정렬한다.
  2. 가중치가 가장 낮은 간선부터 선택을 시작한다.
  3. 선택한 간선이 사이클을 만들지 않는다면 MST에 추가한다.
     - 이를 위해 **Union-Find(Disjoint Set Union)** 자료구조를 사용하여 사이클 여부를 검사한다.
  4. 선택된 간선의 개수가 (정점 개수 - 1)이 되면 종료한다.

- 특징:
  - **그리디 알고리즘** 기반
  - **간선 중심** 알고리즘
  - **음의 가중치**도 처리 가능
  - 희소 그래프(Sparse Graph)에 유리함

- 장점:
  - 구현이 비교적 간단
  - 간선의 가중치가 음수여도 문제없이 동작
  - 간선 수가 적은 경우 효율적

- 단점:
  - 간선 정렬이 반드시 필요 → 정렬 비용 발생
  - 동적(온라인) 그래프에 적용하기 어려움 (간선이 실시간으로 추가되는 경우)

- 시간 복잡도:
  - 간선 정렬에 \( O(E \log E) \) 필요
  - Union-Find 연산은 거의 \( O(1) \) (거의 상수 시간)
  - 전체적으로 \( O(E \log E) \) 또는 \( O(E \log V) \)

---

### Prim 알고리즘
- 아이디어: **정점에서 시작하여 늘려가는 방식으로 MST를 만든다.**
- 동작 과정:
  1. 임의의 시작 정점을 선택한다.
  2. 해당 정점에서 연결된 간선 중 가중치가 가장 작은 간선을 선택한다.
  3. 새로운 정점을 방문 처리하고, 해당 정점과 연결된 간선들을 우선순위 큐에 삽입한다.
  4. 우선순위 큐에서 가장 가중치가 낮은 간선을 선택하고, 방문하지 않은 정점을 MST에 추가한다.
  5. 모든 정점이 선택될 때까지 과정을 반복한다.

- 특징:
  - **그리디 알고리즘** 기반
  - **정점 중심** 알고리즘
  - 우선순위 큐(Heap 자료구조)를 활용하여 구현

- 장점:
  - 밀집 그래프(Dense Graph)에 효율적
  - 인접 리스트 또는 인접 행렬 활용 가능
  - 구현 시 우선순위 큐를 사용하면 성능이 크게 향상됨

- 단점:
  - 희소 그래프에서는 상대적으로 비효율적
  - 간선 수가 많아지면 큐 삽입 과정이 비교적 비용이 커짐

- 시간 복잡도:
  - 이진 힙(Binary Heap) + 인접 리스트 이용 시: \( O((V+E)\log V) \)
  - 밀집 그래프에서 특히 효율적

---

## 4. Kruskal vs Prim 알고리즘 비교

| 알고리즘 | 방식         | 그래프 적합성   | 자료구조         | 시간복잡도        | 특징 |
|----------|--------------|----------------|------------------|-------------------|------|
| Kruskal  | 간선 중심    | 희소 그래프 | Union-Find 사용 | \( O(E \log E) \) | 정렬 필요, 음의 가중치 처리 가능 |
| Prim     | 정점 중심    | 밀집 그래프 | 우선순위 큐(Heap) | \( O((V+E)\log V) \) | 시작 정점에서 확장, 동적 그래프에는 더 적합 |

---

## 5. MST 활용 예시
- 네트워크 설계 (전선, 케이블, 파이프 연결의 최소 비용)
-교통망 최적화 (도로, 철도 연결 최소 비용)
- 클러스터링(데이터 그룹핑 시 최소 간선 선택 활용)
- 게임 맵 생성 (최소 비용 경로 연결)

---

  -  
