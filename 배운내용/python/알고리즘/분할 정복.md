# 분할 정복 (Divide and Conquer)

복잡한 문제를 더 작은 하위 문제들로 나누어 해결하는 알고리즘 기법

---

## 이진 검색 (Binary Search)
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 계속 검색하는 방법
- 검색 범위를 반으로 줄여가면서 탐색
- 자료가 **정렬된 상태**여야 수행 가능
- 시간 복잡도: O(log n)

---

## 정렬 알고리즘

### 병합 정렬 (Merge Sort)
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- **분할 정복 알고리즘**을 활용
- 큰 데이터셋을 정렬할 때 유용하며, 안정적이고 예측 가능한 성능을 제공

#### 정렬 과정
1. 주어진 배열을 같은 크기의 두 부분 배열로 나눈다.
2. 나눠진 두 부분 배열을 하나의 정렬된 배열로 병합한다.
   - 각 부분 배열의 첫 번째 원소부터 시작하여 더 작은 원소를 새 배열에 넣는다.
   - 이 과정을 반복하여 모든 원소를 정렬된 상태로 병합한다.
3. 위 과정을 재귀적으로 수행하여 전체 배열이 정렬될 때까지 반복한다.

#### 특성
- 시간 복잡도: O(n log n)
- 안정성: O (안정 정렬)
- 적응성: X
- 제자리 정렬: X (추가 메모리 필요)

---

### 퀵 정렬 (Quick Sort)
- 리스트를 기준 아이템(pivot item)을 중심으로 두 부분으로 분할한 뒤, 각각을 재귀적으로 정렬
- 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽에 위치

#### 정렬 과정
1. 리스트에서 하나의 요소를 피벗으로 선택한다.
2. 피벗보다 작은 요소는 왼쪽에, 큰 요소는 오른쪽에 배치한다.
3. 위 과정을 재귀적으로 수행한다.
4. 부분 배열의 크기가 1 이하가 되면 재귀를 종료한다.

#### 특성
- 최악 시간 복잡도: O(n²)
- 평균 및 최선 시간 복잡도: O(n log n)
- 안정성: X (불안정 정렬)
- 적응성: O (데이터 분포에 따라 빠름)
- 제자리 정렬: O (추가 메모리 거의 불필요)
